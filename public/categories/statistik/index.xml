<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Statistik | Norman&#39;s Academic Blog</title>
    <link>https://sefiroth.net/nap/categories/statistik/</link>
      <atom:link href="https://sefiroth.net/nap/categories/statistik/index.xml" rel="self" type="application/rss+xml" />
    <description>Statistik</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>de-de</language><copyright>© in 2017-2020 by Norman Markgraf</copyright><lastBuildDate>Wed, 12 Feb 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://sefiroth.net/nap/img/icon-192.png</url>
      <title>Statistik</title>
      <link>https://sefiroth.net/nap/categories/statistik/</link>
    </image>
    
    <item>
      <title>Eine typische Frage von Studierenden</title>
      <link>https://sefiroth.net/nap/post/eine-typische-frage-von-studierenden/</link>
      <pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://sefiroth.net/nap/post/eine-typische-frage-von-studierenden/</guid>
      <description>&lt;p&gt;Vor kurzem fand ich mal wieder eine Anfrage einer Studierenden in meinem Email Postfach. Die Frage lautete in etwa wie folgt:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Guten Tag Herr Markgraf,&lt;/p&gt;
&lt;p&gt;ich würde gerne die Hypothese untersuchen: Die reduzierte Abhängigkeit des Iphones tagsüber liegt am schönen Wetter.
Dazu habe ich eine Variable &amp;ldquo;iphones.tagsüber.unbeachtet&amp;rdquo; mit 1x, 2x und 3x täglich als Ausprägungen und eine andere Variable &amp;ldquo;wetter.ist.gut&amp;rdquo;, die als Ausprägung &amp;ldquo;Ja&amp;rdquo; und &amp;ldquo;Nein&amp;rdquo; hat.
Welchen Test kann ich dazu zur Überprüfung einer Abhängigkeit nehmen?&lt;/p&gt;
&lt;p&gt;Vielen Dank im Voraus.&lt;/p&gt;
&lt;p&gt;MfG Monika Mustermann&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Natürlich ist diese Frage im Prinzip einfach zu beantworten, sogar von Leuten, die Statistik an einer Hochschule gehört haben. &amp;ndash; Aber da ich ja auch sonst nichts zu tun habe gebe ich gerne statistische Hilfestellung für Studierende. Sicher verdiene ich damit eigentlich Geld, also ist es nur natürlich, dass ich so etwas volllkommen unendgeldlich mache. Und wieso sollten Studierende einfach mal ein Buch in die Hand nehmen und selber nachdenken? Es gibt vermutlich keine Bücher zu diesem Thema, denn es ist gar sicher eine Geheimwissenschaft. Und wieso sollte man dann also seine Betreuungsperson zu diesem Probem fragen? &amp;ndash; Egal.&lt;/p&gt;
&lt;p&gt;Was haben wir hier vorliegen? &amp;ndash; Im einfachsten Fall sind es zwei kategoriale Variablen und wir wollen sehen ob diese von einenander (un-)Abhängig sind.
Mangels tatsächlicher Daten basten wir uns einfach mal ein Beispiel:&lt;/p&gt;
&lt;h3 id=&#34;wir-basten-uns-ein-beispiel&#34;&gt;Wir basten uns ein Beispiel&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(mosaic)
set.seed(123)
n = 176
daten &amp;lt;- data.frame(
  iphones.tagsüber.unbeachtet = sample(rep(c(&amp;quot;1xtäglich&amp;quot;,&amp;quot;2xtäglich&amp;quot;,&amp;quot;3xtäglich&amp;quot;),n),n),
  wetter.ist.gut = sample(rep(c(&amp;quot;Ja&amp;quot;,&amp;quot;Nein&amp;quot;),n),n)
)
head(daten)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   iphones.tagsüber.unbeachtet wetter.ist.gut
## 1                   1xtäglich             Ja
## 2                   1xtäglich           Nein
## 3                   2xtäglich             Ja
## 4                   3xtäglich           Nein
## 5                   1xtäglich             Ja
## 6                   2xtäglich             Ja
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ein-blick-auf-kennzahlen-und-visualisierungsmöglichkeiten&#34;&gt;Ein Blick auf Kennzahlen und Visualisierungsmöglichkeiten&lt;/h3&gt;
&lt;p&gt;Man kann diese Daten als Kreuztabelle zusammenfassen und diese dann mit Hilfe eines Mosaicplots darstellen:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tally(iphones.tagsüber.unbeachtet ~ wetter.ist.gut, data=daten)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                            wetter.ist.gut
## iphones.tagsüber.unbeachtet Ja Nein
##                   1xtäglich 29   33
##                   2xtäglich 34   26
##                   3xtäglich 27   27
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;mosaicplot(wetter.ist.gut ~ iphones.tagsüber.unbeachtet, data=daten)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-02-12-eine-typische-frage-von-studierenden_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;von-der-forschungsthese-zur-hypothese-teil-1&#34;&gt;Von der Forschungsthese zur Hypothese (Teil 1)&lt;/h3&gt;
&lt;p&gt;Um nun zwischen abhänig und unabhängig statitisch zu unterscheiden, sollte man sich die Null- und Alternativhypothese genau überlegen und &lt;em&gt;operationalisieren&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Ein Blick auf die (orginal) Forschungsthese: &amp;ldquo;Die reduzierte Abhängigkeit des Iphones tagsüber liegt am schönen Wetter.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Okay, wir formulieren etwas um: &amp;ldquo;Es besteht ein Zusammenhang zwischen &amp;lsquo;schönem Wetter&amp;rsquo; und dem &amp;lsquo;Iphone tagsüber unbeachtet&amp;rsquo; lassen.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Warum diese unterschiedliche Formulierung? &amp;ndash; Nun, in der orginal Forschungsthese wird ein kausal Zusammenhang geprüft. Da es sich vermutlich um eine Beobachtungstudie handelt können wir einen solchen Ursache-Wirkungs-Zusammenhang aber hier nicht so einfach (bis gar nicht) prüfen. Zwar kann man von außen sagen: &amp;ldquo;Wenn es einen Zusammenhang gibt, dann führt das schöne Wetter zur Nichtbeachtung.&amp;rdquo; statitisch können wir hier aber aktuell nur den Zusammenhang (und zwar ungerichtget!) testen. Liegt dieser &lt;strong&gt;nicht&lt;/strong&gt; vor, so spricht erstmal auch nichts für einen kausalen Zusammenhang, aber ein Zusammenhang an sich spricht noch nicht für einen kausalen Zusammenhang!&lt;/p&gt;
&lt;p&gt;Aus der umformulierten Forschungsfrage können wir die Alternativ- und auch die Nullhypothese ableiten:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Alternativhypothese:&lt;/strong&gt; Es besteht ein Zusammenhang zwischen &amp;lsquo;schönem Wetter&amp;rsquo; und dem &amp;lsquo;Iphone tagsüber unbeachtet&amp;rsquo; lassen.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nullhypothese:&lt;/strong&gt; Es besteht &lt;strong&gt;kein&lt;/strong&gt; Zusammenhang zwischen &amp;lsquo;schönem Wetter&amp;rsquo; und dem &amp;lsquo;Iphone tagsüber unbeachtet&amp;rsquo; lassen.&lt;/p&gt;
&lt;h2 id=&#34;wie-kann-man-nun-den-zusammenhang-messen-und-wie-sieht-kein-zusammenhang-dabei-aus&#34;&gt;Wie kann man nun den Zusammenhang &lt;em&gt;messen&lt;/em&gt; und wie sieht &lt;em&gt;kein Zusammenhang&lt;/em&gt; dabei aus?&lt;/h2&gt;
&lt;p&gt;Um zu sehen ob unsere Werte keinen Zusammenhang haben, also rein zufällig sind, oder es einen inneren Zusammenhang gibt müssen wir die äußeren von den inneren Häufigkeiten trennen.&lt;/p&gt;
&lt;p&gt;Konkret heißt das, wir schauen uns an wie die Häufigkeiten oder auch Verteilung der einzelnen Variabeln ausssehen:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tally(~ wetter.ist.gut, data=daten)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## wetter.ist.gut
##   Ja Nein 
##   90   86
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tally(~ iphones.tagsüber.unbeachtet, data=daten)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## iphones.tagsüber.unbeachtet
## 1xtäglich 2xtäglich 3xtäglich 
##        62        60        54
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;freiheitsgrade&#34;&gt;Freiheitsgrade&lt;/h4&gt;
&lt;p&gt;Die Werte innerhalb der Kreuztabelle oben werden im wesendlichen durch diese Werte bestimmt. Die außeren Werte sind also unsere Rahmenbedingungen. Dabei ist der Einfluss der sogenannten &lt;em&gt;Randhäufigkeiten&lt;/em&gt; (&lt;em&gt;Marginale Häufigkeit&lt;/em&gt;) nicht zu unterschätzen. Denn wenn wir diese als &lt;em&gt;fix&lt;/em&gt;/&lt;em&gt;gegeben&lt;/em&gt; ansehen, können wir nur mit den sechs Werten in der Mitte unserer Kreuztabelle &lt;em&gt;spielen&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Doch sind nicht alle sechs Werte wirklich frei. Denn um zum Beispiel die Summe 62 in der ersten Zeile zu erhalten haben wir ja die Summe von 29 und 33 gebildet.&lt;/p&gt;
&lt;p&gt;Ist nun der Rand, also 62, fest, so kann ich die beiden Summanden nicht mehr frei wählen, denn&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$62 = 29 + 33$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;impliziert ja, dass ich allgemeiner
&lt;code&gt;$$62 = x + y$$&lt;/code&gt;
habe und somit durch
&lt;code&gt;$$x = 62 - y \qquad\text{ bzw. }\qquad y = 62 - x$$&lt;/code&gt;
immer nur eine der Variabeln &lt;code&gt;\(x\)&lt;/code&gt; oder &lt;code&gt;\(y\)&lt;/code&gt; wirklich frei zu wählen ist.&lt;/p&gt;
&lt;p&gt;Da dies für jede Zeile, aber auch für jede Spalte gilt, denn z.B. ist die Summe der ersten Spalte gegeben durch&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$90 = 29 + 34 + 27,$$&lt;/code&gt;
sind von den sechs Werten in der Kreuztabelle in der Tat nur 2 Werte wirklich frei zu wählen.
Wir haben also ein Problem mit &lt;em&gt;2 Freiheitsgraden&lt;/em&gt;, man schreibt das kurz mit &lt;code&gt;\(df=2\)&lt;/code&gt; (&lt;em&gt;df&lt;/em&gt; steht dabei für &lt;em&gt;degree of freedom&lt;/em&gt;).&lt;/p&gt;
&lt;h3 id=&#34;unabhängigkeit-in-der-statistik&#34;&gt;Unabhängigkeit in der Statistik&lt;/h3&gt;
&lt;p&gt;Wir sagen in der Statistik, dass ein gemeinsames Ereignis unabhängig ist wenn sich das Ereignis als Produkt der beiden Einzelereignisse berechnen lässt.
Seien &lt;code&gt;\(A\)&lt;/code&gt; und &lt;code&gt;\(B\)&lt;/code&gt; also zwei Ereignisse, dann gilt im Falle der Unabhängigkeit:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$P(A \cap B) = P(A) \cdot P(B)$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Wir können diese Definition aus der Wahrscheinlichkeitstheorie an unser Problem adaptieren, in dem wir die Wahrscheinlichkeiten durch die relativen Häufigkeiten ersetzen.&lt;/p&gt;
&lt;p&gt;Der Wert für das Ereignis &amp;ldquo;iphone.tagsüber.unbeachtet = 1xtäglich&lt;code&gt; und das&lt;/code&gt;wetter.ist.gut=ja` wird im Falle der Unabhägigkeit
durch die beiden Randhäufigkeiten bestimmt:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$62 \cdot 90 = 31.7045455$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Wir können nun also eine Kreuztabelle erstellen, wie sie seien müsste, falls wir tatsächlich &lt;em&gt;statitische Unabhängigkeit&lt;/em&gt; hätten. Wir nutzen dafür eine sehr allgemein gehaltene Funktion &lt;code&gt;expectation.tab()&lt;/code&gt;, der wir eine Tabelle mit den Häufigkeiten der Beobachtungen geben und die uns dann die Tabelle liefert, wie sie aussehen würde, falls tatsächlich &lt;em&gt;statitische Unabhängigkeit&lt;/em&gt; heschen würde.
Die Tabelle mit den beobchteten Werten speichern wir in &lt;code&gt;obs.tab&lt;/code&gt;, die der erwarteten Werte in &lt;code&gt;exp.tab&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;expectation.tab &amp;lt;- function(tab.obs) {
  max.i &amp;lt;- length(tab.obs[1,])
  max.j &amp;lt;- length(tab.obs[,1])
  
  # Randhäufigkeiten 
  x &amp;lt;- rep(0, max.i)
  for(i in 0:max.i) x[i] = sum(tab.obs[,i])

  y &amp;lt;- rep(0, max.j)
  for(j in 0:max.j) y[j] = sum(tab.obs[j,])

    # Anzahl aller Beobachtungen
  n = sum(tab.obs)

  mtx &amp;lt;- c()
  
  for(i in 0:max.i){
    for(j in 0:max.j) {
       mtx &amp;lt;- c(mtx, (x[i] * y[j] / n))
    }
  }
  ret &amp;lt;- matrix(
      mtx,#rep(0, length(tab.obs)),
      nrow = max.j,
      ncol = max.i
  )
  
  # Spalten und Zeilennamen übernehmen
  colnames(ret) &amp;lt;- colnames(tab.obs)
  rownames(ret) &amp;lt;- rownames(tab.obs)
  
  return(ret)
}

obs.tab &amp;lt;- tally(iphones.tagsüber.unbeachtet ~ wetter.ist.gut, data=daten)
exp.tab &amp;lt;- expectation.tab(obs.tab)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Schauen wir uns die beiden Tabellen kurz an. Zuerst die der beobachteten Werte:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;obs.tab
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                            wetter.ist.gut
## iphones.tagsüber.unbeachtet Ja Nein
##                   1xtäglich 29   33
##                   2xtäglich 34   26
##                   3xtäglich 27   27
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dann die der erwarteten Werte:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;exp.tab
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                 Ja     Nein
## 1xtäglich 31.70455 30.29545
## 2xtäglich 30.68182 29.31818
## 3xtäglich 27.61364 26.38636
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;was-können-wir-nun-messen&#34;&gt;Was können wir nun messen?&lt;/h3&gt;
&lt;p&gt;Unsicherheit und Zufall spielen eine große Rolle. Wir können also nicht erwarten, dass die Werte für die Kreuztabelle in der Realität genau getroffen werden. (Vorallem, weil wir hier ja mit Nachkommastellen arbeiten!) Aber wir können versuchen den Abstand zu diesen Werten zu messen. Je weiter weg die Werte in der Kreuztabelle von den theoretischen Werten liegen, um so unwarscheinlicher ist es, dass die Werte zufällig aus einer unabhängigen Population gezogen wurden. D.h. wir könnten uns für eine Abhägigkeit aussprechen.&lt;/p&gt;
&lt;h4 id=&#34;messen-mit-dem-absolutabstand&#34;&gt;Messen mit dem Absolutabstand?&lt;/h4&gt;
&lt;p&gt;Man könnte nun auf die Idee kommen die Abstände an jeder Stelle zu messen und den absoluten Abstand zu summieren:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum(abs(obs.tab-exp.tab))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 13.27273
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nur was sagt dieser Wert aus? &amp;ndash; Ist das ein kleiner Abstand oder ein großer?&lt;/p&gt;
&lt;p&gt;Wir brauchen Referenzwerte zur Orientierung. Die Idee: &lt;strong&gt;Permutationstest&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Funktion zur Berechnung der absoluten Differenz zwischen
# beobachteten und erwarteten Werte
diffabsobsexp &amp;lt;- function(obs, exp) {
  return(sum(abs(obs-exp)))
}

# Absolute Abweichung der gemessenen Werte
obs.abs &amp;lt;- diffabsobsexp(obs.tab, exp.tab)

# Erzeugen der Nullverteilung
NullVert  &amp;lt;- do(1000) * diffabsobsexp(tally(iphones.tagsüber.unbeachtet ~ shuffle(wetter.ist.gut), data=daten), exp.tab)
gf_histogram(~ diffabsobsexp, data=NullVert) %&amp;gt;%
  gf_vline(xintercept = ~ obs.abs, color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-02-12-eine-typische-frage-von-studierenden_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Wir können nun den p-Wert abschätzen mit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;prop( ~ diffabsobsexp &amp;gt;= obs.abs, data=NullVert)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## prop_TRUE 
##     0.559
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Doch haben wir alle Werte richtig bewertet? Wenn wir jeden einzelne Differenz noch durch den erwarteten Wert teilen erhalten wir:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Funktion zur Berechnung der korrigierten absoluten 
# Differenz zwischen beobachteten und erwarteten Werten
diffabsobsexpkor &amp;lt;- function(obs, exp) {
  return(sum((abs(obs-exp))/exp))
}

# Absolute Abweichung der gemessenen Werte -- korrigiert
obs.abs &amp;lt;- diffabsobsexpkor(obs.tab, exp.tab)

# Erzeugen der Nullverteilung
NullVert  &amp;lt;- do(1000) * diffabsobsexpkor(tally(iphones.tagsüber.unbeachtet ~ shuffle(wetter.ist.gut), data=daten), exp.tab)
gf_histogram(~ diffabsobsexpkor, data=NullVert) %&amp;gt;%
  gf_vline(xintercept = ~ obs.abs, color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-02-12-eine-typische-frage-von-studierenden_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Wir können nun den p-Wert abschätzen mit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;prop( ~ diffabsobsexpkor &amp;gt;= obs.abs, data=NullVert)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## prop_TRUE 
##     0.619
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ist der absolute Abstand überhaupt gut gewählt? &amp;ndash; Wäre nicht eher der quadratische Abstand angebracht?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Funktion zur Berechnung der quadratischen 
# Differenz zwischen beobachteten und erwarteten Werten
diffquad &amp;lt;- function(obs, exp) {
  return(sum((obs-exp)^2))
}

# Quadratische Abweichung der gemessenen Werte
obs.abs &amp;lt;- diffquad(obs.tab, exp.tab)

# Erzeugen der Nullverteilung
NullVert  &amp;lt;- do(1000) * diffquad(tally(iphones.tagsüber.unbeachtet ~ shuffle(wetter.ist.gut), data=daten), exp.tab)
gf_histogram(~ diffquad, data=NullVert) %&amp;gt;%
  gf_vline(xintercept = ~ obs.abs, color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-02-12-eine-typische-frage-von-studierenden_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;672&#34; /&gt;
Wir können nun den p-Wert abschätzen mit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;prop( ~ diffquad &amp;gt;= obs.abs, data=NullVert)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## prop_TRUE 
##      0.52
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wenn man nun den quadratischen Abstand noch durch die Erwartung teilt:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Funktion zur Berechnung der korrigierten quadratischen 
# Differenz zwischen beobachteten und erwarteten Werten
diffquadkor &amp;lt;- function(obs, exp) {
  return(sum(((obs-exp)^2)/exp))
}

# Quadratische Abweichung der gemessenen Werte -- korrigiert
obs.abs &amp;lt;- diffquadkor(obs.tab, exp.tab)

# Erzeugen der Nullverteilung
NullVert  &amp;lt;- do(1000) * diffquadkor(tally(iphones.tagsüber.unbeachtet ~ shuffle(wetter.ist.gut), data=daten), exp.tab)
gf_histogram(~ diffquadkor, data=NullVert) %&amp;gt;%
  gf_vline(xintercept = ~ obs.abs, color=&amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-02-12-eine-typische-frage-von-studierenden_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;672&#34; /&gt;
Wir können nun den p-Wert abschätzen mit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;prop( ~ diffquadkor &amp;gt;= obs.abs, data=NullVert)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## prop_TRUE 
##     0.571
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An Hand der p-Werte können wir nun über die Nullhypothese entscheiden:&lt;/p&gt;
&lt;h3 id=&#34;was-sagt-die-klassische-statistik&#34;&gt;Was sagt die klassische Statistik?&lt;/h3&gt;
&lt;p&gt;In der klassischen Statistik könnte man hier den &lt;code&gt;\(\chi^2\)&lt;/code&gt;-Unabhängigkeitstest anwenden:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;xchisq.test(iphones.tagsüber.unbeachtet ~ wetter.ist.gut, data=daten)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## 	Pearson&#39;s Chi-squared test
## 
## data:  x
## X-squared = 1.2345, df = 2, p-value = 0.5394
## 
##    29       33   
## (31.70)  (30.30) 
## [0.231]  [0.241] 
## &amp;lt;-0.48&amp;gt;  &amp;lt; 0.49&amp;gt; 
##    
##    34       26   
## (30.68)  (29.32) 
## [0.359]  [0.376] 
## &amp;lt; 0.60&amp;gt;  &amp;lt;-0.61&amp;gt; 
##    
##    27       27   
## (27.61)  (26.39) 
## [0.014]  [0.014] 
## &amp;lt;-0.12&amp;gt;  &amp;lt; 0.12&amp;gt; 
##    
## key:
## 	observed
## 	(expected)
## 	[contribution to X-squared]
## 	&amp;lt;Pearson residual&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aber es gibt auch den (exakten) Fisher-Test:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fisher.test(obs.tab, alternative = &amp;quot;greater&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## 	Fisher&#39;s Exact Test for Count Data
## 
## data:  obs.tab
## p-value = 0.5609
## alternative hypothesis: greater
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;fazit&#34;&gt;Fazit&lt;/h3&gt;
&lt;p&gt;Wir können die p-Werte der einzelnen Tests nun gegenüber stellen:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;##        abs. Abweichung   kor. abs. Abweichung      quadr. Abweichung 
##              0.5590000              0.6190000              0.5200000 
## kor. quadr. Abweichung        ChiQuadrat-Test            Fisher-Test 
##              0.5710000              0.5394367              0.5609340
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Was die Entscheidung für oder gegen die Nullhypothese angeht, hat jeder dieser Test (in der Regel) die selbe Entscheidung als Konsequenz.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Warum das Nachrechnen von Veröffentlichungen so wichtig ist</title>
      <link>https://sefiroth.net/nap/post/warum-das-nachrechnen-von-veroeffentlichungen-so-wichtig-ist/</link>
      <pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://sefiroth.net/nap/post/warum-das-nachrechnen-von-veroeffentlichungen-so-wichtig-ist/</guid>
      <description>
&lt;script src=&#34;../../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;Im Internet fand ich vor kurzem einen sehr interessanten &lt;a href=&#34;http://www.stefanbartz.de/dateien/Vorsicht-bei-der-sigma-Regel.pdf&#34;&gt;Text&lt;/a&gt; von &lt;a href=&#34;http://www.stefanbartz.de&#34;&gt;Stefan Bart&lt;/a&gt;. Eine Aufgabe daraus fand meine besondere Aufmerksamkeit.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;HSB gesucht (Grundgesamtheit mit &lt;span class=&#34;math inline&#34;&gt;\(H_0 \rightarrow\)&lt;/span&gt; Stichprobe)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Es soll die Nullhypothese, dass die 500 Mädchen und 500 Jungen der Schule gleichintelligent sind, getestet werden.
Dazu werden 200 zufällige Junge-Mädchen-Paare gebildet.
Bei 112 - von hatte der Junge einen höheren IQ. Ist die Abweichung vom Mittelwert signifikant?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Als Lösungen wurden vorgeschlagen:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: lower-alpha&#34;&gt;
&lt;li&gt;&lt;em&gt;grobe Näherung&lt;/em&gt;:
&lt;span class=&#34;math display&#34;&gt;\[x \in [n \cdot p_0 \pm \sqrt{n}\,] = [200 \cdot 0{,}5 \pm \sqrt{200}\,] \approx [85{,}85786; 114{,}1421] \approx [85; 115]\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;bessere Näherung&lt;/em&gt;:
&lt;span class=&#34;math display&#34;&gt;\[\begin{aligned}x \in \left[n \cdot p_0 \pm \Phi(0{,}975) \sqrt{n \cdot p_0 (1-p_0)}\,\right] &amp;amp;\approx \left[n \cdot p_0 \pm 1{,}96 \cdot \sqrt{n \cdot p_0 \cdot(1-p_0)} \,\right] \\ &amp;amp;\approx \left[200 \cdot 0{,}5 \pm 1.959964 \cdot \sqrt{200 \cdot 0{,}5 \cdot (1-0{,}5)}\,\right] \\ &amp;amp;\approx \left[86{,}14096; 113{,}859\right] \\&amp;amp;\approx \left[86; 114\right]\end{aligned}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;exakte Lösung&lt;/em&gt;:
&lt;span class=&#34;math display&#34;&gt;\[x \in [89; 111]\]&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Auf Grundlage dieser drei Lösungen wurde dann enschieden, ob die Abweichung signifikant ist, also 112 im oder eben nicht im berechneten Intervall liegt. &lt;em&gt;Ergebnis:&lt;/em&gt; a), b) liefern nicht signifikante und c) ein signifikantes Ergebnis.&lt;/p&gt;
&lt;p&gt;Die Frage bleibt, was in der Aufgabenstellung mit “200 zufällige Junge-Mädchen-Paaren” gemeint ist.&lt;/p&gt;
&lt;p&gt;Es gilt ja bekannter maßen:
- Eine &lt;em&gt;uneingeschränkte Zufallsstichprobe&lt;/em&gt; erhält man z. B. bei einem &lt;em&gt;Ziehen ohne Zurücklegen&lt;/em&gt; (&lt;span class=&#34;math inline&#34;&gt;\(\rightarrow\)&lt;/span&gt; Hypergeometische Verteilung).
- Eine &lt;em&gt;einfache Zufallsstichprobe&lt;/em&gt; z. B. bei einem &lt;em&gt;Ziehen mit Zurücklegen&lt;/em&gt; (&lt;span class=&#34;math inline&#34;&gt;\(\rightarrow\)&lt;/span&gt; Binomialverteilung).&lt;/p&gt;
&lt;p&gt;Rechnet man mit Hilfe von &lt;em&gt;R&lt;/em&gt; die axakte Lösung nach, so erhält man:&lt;/p&gt;
&lt;p&gt;Für die Binomialverteilung (die “bessere Näherung”):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pl &amp;lt;- 0.025 # 2,5% als untere Grenze
pr &amp;lt;- 0.975 # 97,5% als obere Grenze

iu &amp;lt;- qbinom(pl, 200, prob=0.5)
io &amp;lt;- qbinom(pr, 200, prob=0.5)
c(iu, io) # Ausgabe des (HSB-)Intervalls&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  86 114&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Für die Hypergeometischeverteilung (hier “exakte Lösung” genannt)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;m &amp;lt;- 500 # Anzahl der Mädchen
n &amp;lt;- 500 # Anzahl der Jungen
k &amp;lt;- 200 # Umfang des Stichprobe
pl &amp;lt;- 0.025 # 2,5% als untere Grenze
pr &amp;lt;- 0.975 # 97,5% als obere Grenze

iu &amp;lt;- qhyper(pl, m, n, k) # Linke/untere Intervallgrenze
io &amp;lt;- qhyper(pr, m, n, k) # Rechte/obere Intervallgrenze
c(iu, io) # Ausgabe des (HSB-)Intervalls&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  88 112&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;R&lt;/strong&gt; liefert also aus &lt;em&gt;exakte Lösung&lt;/em&gt; das Intervall &lt;span class=&#34;math inline&#34;&gt;\([88; 112]\)&lt;/span&gt;. Wie kommt es nun über den Unterschied?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;m &amp;lt;- 500 # Anzahl der Mädchen
n &amp;lt;- 500 # Anzahl der Jungen
k &amp;lt;- 200 # Umfang des Stichprobe

p &amp;lt;- dhyper(0:k, m, n, k)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Werte für die linke/untere Intervallgrenzen:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Werte für die linke/untere Intervallgrenzen:
sum(p[0:88])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.02396528&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sum(p[0:89])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.03442166&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Werte für die rechte/untere Intervallgrenzen:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Werte für die rechte/untere Intervallgrenzen:
sum(p[0:110])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9335277&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sum(p[0:111])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9516417&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sum(p[0:112])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9655783&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sum(p[0:113])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9760347&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ist der Unterschied dann also ein Rundungsproblem?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Werden 2,5% und 97,5% nicht genau getroffen, wird hier nicht wie oben, nach außen / .  , sondern in beiden Fällen nach rechts .&lt;br /&gt;
gerundet;
d.h. man nimmt diejenigen Werte in das zu bestimmende Intervall auf, bei denen 2,5% bzw. 97,5% zum ersten Mal
übertroffen werden. Somit verbleiben weniger als 2,5% der Histogrammfläche am linken bzw. rechten Rand.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ich denke nein. – Meine Vermutung ist, dass hier für die rechte Intervallgrenze 95% statt 97,5% genommen wurde.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Moderator und Mediation - Formen der Interaktion bei Analyse von Zusammenhängen</title>
      <link>https://sefiroth.net/nap/post/moderator-und-mediation-formen-der-interaktion-bei-analyse-von-zusammenhaengen/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://sefiroth.net/nap/post/moderator-und-mediation-formen-der-interaktion-bei-analyse-von-zusammenhaengen/</guid>
      <description>&lt;p&gt;Bei der Analyse von Zusammenhängen tauchen sowohl &lt;em&gt;Moderation&lt;/em&gt; als auch &lt;em&gt;Mediation&lt;/em&gt; auf. Es geht um Zusammenhänge zwischen drei Variablen &lt;code&gt;\(X\)&lt;/code&gt;, &lt;code&gt;\(Y\)&lt;/code&gt; und &lt;code&gt;\(M\)&lt;/code&gt;.
Untersucht wird der Effekt einer unabhägigen Variable &lt;code&gt;\(X\)&lt;/code&gt; (&lt;em&gt;Prädiktor&lt;/em&gt;, &lt;em&gt;UV&lt;/em&gt;) auf ein abhängige Variable &lt;code&gt;\(Y\)&lt;/code&gt; (&lt;em&gt;AV&lt;/em&gt;).
Wir untersuchen dies mit einem Regressionsmodell &lt;code&gt;\(Y \sim X\)&lt;/code&gt;.
Dabei wird zusätzlich eine dritte Variable &lt;code&gt;\(M\)&lt;/code&gt; berücksichtigt, die man entweder der &lt;em&gt;Moderator&lt;/em&gt; oder &lt;em&gt;Mediator&lt;/em&gt; nennt.&lt;/p&gt;
&lt;p&gt;Ist die abhängige Variable metrisch, so können wir mittels eine linearer Regression vorgehen, ist die AB dagegen dichotom, so nutzen wir eine logistische Regression.&lt;/p&gt;
&lt;h2 id=&#34;moderation&#34;&gt;Moderation&lt;/h2&gt;
&lt;p&gt;Bei einer &lt;em&gt;Moderation&lt;/em&gt; wirkt die dritte Variable &lt;code&gt;\(M\)&lt;/code&gt; (&lt;em&gt;Moderator&lt;/em&gt;) auf die Beziehung zwischen &lt;code&gt;\(X\)&lt;/code&gt; und &lt;code&gt;\(Y\)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2019-12-31-moderator-und-mediation-formen-der-interaktion-bei-analyse-von-zusammenhängen_files/figure-html/Moderation-1.png&#34; width=&#34;30%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Der Einfluss von &lt;code&gt;\(M\)&lt;/code&gt; ändert also den Effekt von &lt;code&gt;\(X\)&lt;/code&gt; auf &lt;code&gt;\(Y\)&lt;/code&gt;. Der Zusammenhang zwischen &lt;code&gt;\(Y\)&lt;/code&gt; und &lt;code&gt;\(X\)&lt;/code&gt; ist also je nach &lt;code&gt;\(M\)&lt;/code&gt; unterschiedlich.&lt;/p&gt;
&lt;p&gt;Statistisch gesehen liegt eine &lt;em&gt;Interaktion&lt;/em&gt; zwischen &lt;code&gt;\(M\)&lt;/code&gt; und &lt;code&gt;\(X\)&lt;/code&gt; vor.&lt;/p&gt;
&lt;h3 id=&#34;wie-untersucht-man-einen-zusammenhang-auf-eine-moderation&#34;&gt;Wie untersucht man einen Zusammenhang auf eine Moderation?&lt;/h3&gt;
&lt;p&gt;Dazu stellen wir ein Regressionsmodell mit den drei Faktoren &lt;code&gt;\(X\)&lt;/code&gt;, &lt;code&gt;\(M\)&lt;/code&gt; und der Interaktion zwischen &lt;code&gt;\(X\)&lt;/code&gt; und &lt;code&gt;\(M\)&lt;/code&gt; auf.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lm(Y ~ X * M, data=daten)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Oder alternativ:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lm(Y ~ X + M + M:X, data=daten)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Diese drei Faktoren wirken auf &lt;code&gt;\(Y\)&lt;/code&gt;. Ist in diesem Modell die Interaktion &lt;code&gt;\(M:X\)&lt;/code&gt; &lt;em&gt;signifikant&lt;/em&gt;, so liegt eine (signifikante) &lt;em&gt;Moderation&lt;/em&gt; vor.&lt;/p&gt;
&lt;h2 id=&#34;mediation&#34;&gt;Mediation&lt;/h2&gt;
&lt;p&gt;Bei der &lt;em&gt;Mediation&lt;/em&gt; steht die Variable &lt;code&gt;\(M\)&lt;/code&gt; (der &lt;em&gt;Mediator&lt;/em&gt;) sowohl zu &lt;code&gt;\(X\)&lt;/code&gt; als auch zu &lt;code&gt;\(Y\)&lt;/code&gt; in Beziehung.
Der direkte Effekt zwischen &lt;code&gt;\(X\)&lt;/code&gt; und &lt;code&gt;\(Y\)&lt;/code&gt; wird durch den indirekten Effekt über &lt;code&gt;\(M\)&lt;/code&gt; erklärt, also durch
&lt;code&gt;\(X \to  M \to Y\)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2019-12-31-moderator-und-mediation-formen-der-interaktion-bei-analyse-von-zusammenhängen_files/figure-html/Mediator-1.png&#34; width=&#34;30%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;wie-untersucht-man-auf-eine-mediation&#34;&gt;Wie untersucht man auf eine Mediation?&lt;/h3&gt;
&lt;p&gt;In diesem Fall stellen wir mehrere Regressionsmodelle auf. Eine (signifikante) Mediation liegt dann vor, wenn die folgenden Bedinungen erfüllt sind:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;erstesModell &amp;lt;- lm(Y ~ X, data=daten)
zweitesModell &amp;lt;- lm(M ~ X, data=daten)
drittesModell &amp;lt;- lm(Y ~ X + M, data=daten)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Im ersten Modell ($X \to Y$) ist der Regressionskoeffizient von &lt;code&gt;\(X\)&lt;/code&gt; signifikant.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Im zweiten Modell ($X \to M$) ist der Regressionskoeffizient von &lt;code&gt;\(X\)&lt;/code&gt; signifikant.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Im dritten Modell ($X,M \to Y$) ist der Regressionskoeffizient von &lt;code&gt;\(M\)&lt;/code&gt; signifikant und&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;der Regressionskoeffizient von &lt;code&gt;\(X\)&lt;/code&gt; im dritten Modell kleiner als im ersten Modell.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Die ersten Schritte zur Prognose mitteles linearer Regression</title>
      <link>https://sefiroth.net/nap/post/die-ersten-schritte-zur-prognose-mitteles-linearer-regression/</link>
      <pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://sefiroth.net/nap/post/die-ersten-schritte-zur-prognose-mitteles-linearer-regression/</guid>
      <description>&lt;p&gt;Prognosen sind ein wichtiger Bestandteil von Data Science und ist durchaus nicht nur auf moderne Ansätze, wie Neuronale Netze, deep lerning etc. begrenzt. Auch die gute, alte Regression kann ein sehr sinnvolles Mittel sein solche Prognosen zu erstellen.&lt;/p&gt;
&lt;p&gt;Um ein wenig die Ideen hinter Prognosen zu beleuchten wollen wir uns an Prognosen mit dem &lt;strong&gt;tipping&lt;/strong&gt;-Daten heranwagen.&lt;/p&gt;
&lt;h2 id=&#34;einlesen-der-tipping-daten&#34;&gt;Einlesen der tipping-Daten&lt;/h2&gt;
&lt;p&gt;Zuerst laden wir die notwenidgen Pakete:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(mosaic)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Falls die &lt;strong&gt;tipping&lt;/strong&gt;-Daten noch nicht im Verzeichnis liegen, laden wir sie aus dem Internet nach:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (!file.exists(&amp;quot;tips.csv&amp;quot;)) {
  download.file(&amp;quot;https://goo.gl/whKjnl&amp;quot;, destfile = &amp;quot;tips.csv&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nun laden wir die &lt;strong&gt;tipping&lt;/strong&gt;-Daten in den Speicher in den Datenrahmen &lt;code&gt;tips&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tips &amp;lt;- read.csv2(&amp;quot;tips.csv&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wir werfen einen ersten Blick auf die &lt;strong&gt;tipping&lt;/strong&gt;-Daten:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;inspect(tips)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## categorical variables:  
##     name  class levels   n missing
## 1    sex factor      2 244       0
## 2 smoker factor      2 244       0
## 3    day factor      4 244       0
## 4   time factor      2 244       0
##                                    distribution
## 1 Male (64.3%), Female (35.7%)                 
## 2 No (61.9%), Yes (38.1%)                      
## 3 Sat (35.7%), Sun (31.1%), Thur (25.4%) ...   
## 4 Dinner (72.1%), Lunch (27.9%)                
## 
## quantitative variables:  
##         name   class  min      Q1 median      Q3   max      mean        sd   n
## 1 total_bill numeric 3.07 13.3475 17.795 24.1275 50.81 19.785943 8.9024120 244
## 2        tip numeric 1.00  2.0000  2.900  3.5625 10.00  2.998279 1.3836382 244
## 3       size integer 1.00  2.0000  2.000  3.0000  6.00  2.569672 0.9510998 244
##   missing
## 1       0
## 2       0
## 3       0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;vorbereiten-der-test-trainings--und-auswertungesdaten&#34;&gt;Vorbereiten der Test-/Trainings- und Auswertungesdaten&lt;/h2&gt;
&lt;p&gt;Zunächst schränken wir die &lt;strong&gt;tipping&lt;/strong&gt;-Daten auf die Variabeln &amp;ldquo;total_bill&amp;rdquo;, &amp;ldquo;sex&amp;rdquo;, &amp;ldquo;smoker&amp;rdquo;, &amp;ldquo;day&amp;rdquo;, &amp;ldquo;time&amp;rdquo;, &amp;ldquo;size&amp;rdquo; ein und speichern das Ergebnis wieder in &lt;code&gt;tips&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tips %&amp;gt;%
    select(c(&amp;quot;total_bill&amp;quot;, &amp;quot;sex&amp;quot;, &amp;quot;smoker&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;size&amp;quot;)) -&amp;gt; tips
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ziel ist es, den Rechnungsbetrag (&amp;ldquo;total_bill&amp;rdquo;) auf Grundlage der Variabeln &amp;ldquo;sex&amp;rdquo;, &amp;ldquo;smoker&amp;rdquo;, &amp;ldquo;day&amp;rdquo;, &amp;ldquo;time&amp;rdquo; und/oder &amp;ldquo;size&amp;rdquo; vorherzusagen.&lt;/p&gt;
&lt;p&gt;Wir teilen den tipping-Datensatz auf in eine Trainingsdatensatz (&amp;ldquo;tipstrain&amp;rdquo;), einem Testdatensatz (&amp;ldquo;tipstest&amp;rdquo;) und einem Prüfdatensatz (&amp;ldquo;tipspruef&amp;rdquo;).
Der Trainingsdatensatz sollte rund zweidrittel der Daten die wir haben umfassen.
Der Testdatensatz die restlich ca. eindrittel.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;trainings_anteil = 2/3

# n.train ist ein Index für alle Werte, 
# die wir im Trainingsdatensatz haben wollen:
x.train &amp;lt;- sample(1:nrow(tips), floor(trainings_anteil*nrow(tips)))

# Trainingsdatensatz erstellen:
tipstrain &amp;lt;- slice(tips, x.train)

# Prüfdatensatz erstellen, also alles was 
# nicht in den Trainingsdatensatz gekommen ist:
tipspruef &amp;lt;- slice(tips, -(x.train))

# Der Testdatensatz ist der Prüfdatensatz 
# ohne die Variable total_bill:
tipspruef %&amp;gt;% 
    select(-total_bill) -&amp;gt; tipstest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mit dem Tainingsdatensatz versuchen wir nun ein Prognosemodell zu erstellen, um aus den Testdatensatz eine Prognose für &amp;ldquo;total_bill&amp;rdquo; zu erstellen.&lt;/p&gt;
&lt;p&gt;Das Prognose-Modell wird ausschließlich auf Grundlage des Trainingsdatensatzes erstellt. Am Ende wollen wir unser Modell dann aber mit Hilfe des Prüfdatensatzes bewertet.&lt;/p&gt;
&lt;h2 id=&#34;die-datenlage&#34;&gt;Die Datenlage&lt;/h2&gt;
&lt;p&gt;Ein (paar) Blick(e) auf unsere Trainingsdaten:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;gf_point(total_bill ~ jitter(size), color=~time, data=tipstrain)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2019-12-18-die-ersten-schritte-zur-prognose-mitteles-linearer-regression_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;gf_point(total_bill ~ day | time, color = ~ sex, data=tipstrain)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2019-12-18-die-ersten-schritte-zur-prognose-mitteles-linearer-regression_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;prognosemodel-nullmodell&#34;&gt;Prognosemodel: Nullmodell&lt;/h2&gt;
&lt;h3 id=&#34;aufstellen-des-nullmodel-aka-regression-mit-der-achse&#34;&gt;Aufstellen des Nullmodel aka Regression mit der Achse&lt;/h3&gt;
&lt;p&gt;Wir erstellen das Nullmodell wie folgt:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lm.null &amp;lt;- lm( total_bill ~ 1, data=tipstrain)
summary(lm.null)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = total_bill ~ 1, data = tipstrain)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -13.159  -6.989  -2.429   4.171  30.401 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  20.4086     0.7311   27.91   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 9.306 on 161 degrees of freedom
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Das Nullmodell sagt in jedem Fall den Rechnungsbetrag vorher als den Mittelwert der Trainingsdaten!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;mean(~ total_bill, data=tipstrain)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 20.40864
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nun bestimmten wir mit Hilfe des Nullmodells &amp;ldquo;lm.null&amp;rdquo; eine Vorhersage für die Testdaten:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;predict.null &amp;lt;- predict(lm.null, newdata=tipstest)
head(predict.null)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        1        2        3        4        5        6 
## 20.40864 20.40864 20.40864 20.40864 20.40864 20.40864
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wie gesagt, das Nullmodell liefert als Prognose immer den Mittelwert der Trainingsdaten zurück,
das mathematische Nullmodell lautet also:&lt;/p&gt;
&lt;p&gt;$$\widehat{total_bill_i} = 20.408642  $$&lt;/p&gt;
&lt;h3 id=&#34;auswertung-des-nullmodells&#34;&gt;Auswertung des Nullmodells&lt;/h3&gt;
&lt;p&gt;Zur Auswertung Nutzen wir den &lt;em&gt;mittleren Absolutabstand&lt;/em&gt; zwischen der Vorhersage und den Prüfdaten:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;maa.null &amp;lt;-sum( abs( tipspruef$total_bill - predict.null))
maa.null
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 544.772
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;prognosemodell-lineare-regression-gegen-size-als-metrischer-wert&#34;&gt;Prognosemodell: Lineare Regression gegen &amp;ldquo;size&amp;rdquo; als metrischer Wert&lt;/h2&gt;
&lt;h3 id=&#34;aufstellen-des-modells&#34;&gt;Aufstellen des Modells&lt;/h3&gt;
&lt;h3 id=&#34;auswertung-des-regressionsmodell&#34;&gt;Auswertung des Regressionsmodell&lt;/h3&gt;
</description>
    </item>
    
  </channel>
</rss>
